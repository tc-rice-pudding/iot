import { __values } from '../../node_modules/tslib/tslib.es6.js';
import { getValNumber, getVal, getValHex, getAttrBoolean } from '../../OpenXML.js';
import { parseBorders } from '../../parse/parseBorder.js';
import { parseShdColor } from '../../parse/parseColor.js';
import { parseSize } from '../../parse/parseSize.js';
import { ST_TblLayoutType } from '../Types.js';
import { parseTblCellSpacing, parseCellMargin, parseInsideBorders, parseTblWidth } from './table/Tc.js';
import { Tr } from './table/Tr.js';

/**
 * http://officeopenxml.com/WPtable.php
 */
/**
 * 表格的 jc 需要使用 float 来实现
 * http://officeopenxml.com/WPtableAlignment.php
 */
function parseTblJc(element, cssStyle) {
    var val = getVal(element);
    switch (val) {
        case 'left':
        case 'start':
            // TODO: 会导致前面的文字掉下去，感觉还是不能支持这个功能
            // cssStyle['float'] = 'left';
            break;
        case 'right':
        case 'end':
            cssStyle['float'] = 'right';
    }
}
/**
 * 这个其实分左右，但目前只支持左，右可能是阿拉伯语？
 * http://webapp.docx4java.org/OnlineDemo/ecma376/WordML/tblInd_2.html
 */
function parseTblInd(element, style) {
    var width = parseTblWidth(element);
    if (width) {
        style['margin-left'] = width;
    }
}
function parseTblW(element, style) {
    var width = parseTblWidth(element);
    if (width) {
        style['width'] = width;
    }
}
/**
 * http://officeopenxml.com/WPtableLayout.php
 */
function parseTblLayout(element, style) {
    var type = element.getAttribute('w:type');
    if (type === ST_TblLayoutType.fixed) {
        style['table-layout'] = 'fixed';
    }
}
function parseTblGrid(element) {
    var e_1, _a;
    var gridCol = [];
    var gridColElements = element.getElementsByTagName('w:gridCol');
    try {
        for (var gridColElements_1 = __values(gridColElements), gridColElements_1_1 = gridColElements_1.next(); !gridColElements_1_1.done; gridColElements_1_1 = gridColElements_1.next()) {
            var gridColElement = gridColElements_1_1.value;
            var w = parseSize(gridColElement, 'w:w');
            gridCol.push({ w: w });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (gridColElements_1_1 && !gridColElements_1_1.done && (_a = gridColElements_1.return)) _a.call(gridColElements_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return gridCol;
}
// http://webapp.docx4java.org/OnlineDemo/ecma376/WordML/ST_TblStyleOverrideType.html
// val 是旧的格式
function parseTblLook(child) {
    var tblLook = {};
    var tblLookVal = getValHex(child);
    if (getAttrBoolean(child, 'firstRow', false) || tblLookVal & 0x0020) {
        tblLook['firstRow'] = true;
    }
    if (getAttrBoolean(child, 'lastRow', false) || tblLookVal & 0x0040) {
        tblLook['lastRow'] = true;
    }
    if (getAttrBoolean(child, 'firstColumn', false) || tblLookVal & 0x0080) {
        tblLook['firstColumn'] = true;
    }
    if (getAttrBoolean(child, 'lastColumn', false) || tblLookVal & 0x0100) {
        tblLook['lastColumn'] = true;
    }
    if (getAttrBoolean(child, 'noHBand', false) || tblLookVal & 0x0200) {
        tblLook['noHBand'] = true;
    }
    else {
        tblLook['noHBand'] = false;
    }
    if (getAttrBoolean(child, 'noVBand', false) || tblLookVal & 0x0400) {
        tblLook['noVBand'] = true;
    }
    else {
        tblLook['noVBand'] = false;
    }
    return tblLook;
}
/**
 * http://webapp.docx4java.org/OnlineDemo/ecma376/WordML/tblpPr.html
 * 只支持部分
 */
function parsetTlpPr(word, child, style) {
    // 如果设置 padding 会导致绝对定位不准确，所以一旦设置就不支持
    if (typeof word.renderOptions.padding === 'undefined') {
        var tplpX = parseSize(child, 'w:tblpX');
        var tplpY = parseSize(child, 'w:tblpY');
        style.position = 'absolute';
        style.top = tplpY;
        style.left = tplpX;
    }
    // 之前想用 float 来实现，但是会导致文字掉下去
    // const topFromText = parseSize(child, 'w:topFromText');
    // const bottomFromText = parseSize(child, 'w:bottomFromText');
    // const rightFromText = parseSize(child, 'w:rightFromText');
    // const leftFromText = parseSize(child, 'w:leftFromText');
    // style['float'] = 'left';
    // style['margin-bottom'] = addSize(style['margin-bottom'], bottomFromText);
    // style['margin-left'] = addSize(style['margin-left'], leftFromText);
    // style['margin-right'] = addSize(style['margin-right'], rightFromText);
    // style['margin-top'] = addSize(style['margin-top'], topFromText);
}
var Table = /** @class */ (function () {
    function Table() {
        this.properties = {};
        this.tblGrid = [];
        this.trs = [];
    }
    Table.parseTablePr = function (word, element) {
        var e_2, _a;
        var properties = {};
        var tableStyle = {};
        var tcStyle = {};
        properties.tblLook = {};
        properties.cssStyle = tableStyle;
        properties.tcCSSStyle = tcStyle;
        try {
            for (var _b = __values(element.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                var tagName = child.tagName;
                switch (tagName) {
                    case 'w:tblBorders':
                        parseBorders(word, child, tableStyle);
                        properties.insideBorder = parseInsideBorders(word, child);
                        break;
                    case 'w:tcBorders':
                        parseBorders(word, child, tableStyle);
                        break;
                    case 'w:tblInd':
                        parseTblInd(child, tableStyle);
                        break;
                    case 'w:jc':
                        parseTblJc(child, tableStyle);
                        break;
                    case 'w:tblCellMar':
                    case 'w:tcMar':
                        // http://webapp.docx4java.org/OnlineDemo/ecma376/WordML/tblCellMar_1.html
                        parseCellMargin(child, tcStyle);
                        break;
                    case 'w:tblStyle':
                        properties.pStyle = getVal(child);
                        break;
                    case 'w:tblW':
                        parseTblW(child, tableStyle);
                        break;
                    case 'w:shd':
                        // http://officeopenxml.com/WPtableShading.php
                        tableStyle['background-color'] = parseShdColor(word, child);
                        break;
                    case 'w:tblCaption':
                        properties.tblCaption = getVal(child);
                        break;
                    case 'w:tblCellSpacing':
                        parseTblCellSpacing(child, tableStyle);
                        break;
                    case 'w:tblLayout':
                        parseTblLayout(child, tableStyle);
                        break;
                    case 'w:tblLook':
                        properties.tblLook = parseTblLook(child);
                        break;
                    case 'w:tblStyleRowBandSize':
                        properties.rowBandSize = getValNumber(child);
                        break;
                    case 'w:tblStyleColBandSize':
                        properties.colBandSize = getValNumber(child);
                        break;
                    case 'w:tblpPr':
                        parsetTlpPr(word, child, tableStyle);
                        break;
                    default:
                        console.warn('parseTableProperties unknown tag', tagName, child);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return properties;
    };
    Table.fromXML = function (word, element) {
        var e_3, _a;
        var table = new Table();
        // 用于计算列的跨行，这里记下前面的跨行情况
        var rowSpanMap = {};
        try {
            for (var _b = __values(element.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                var tagName = child.tagName;
                switch (tagName) {
                    case 'w:tblPr':
                        table.properties = Table.parseTablePr(word, child);
                        break;
                    case 'w:tr':
                        table.trs.push(Tr.fromXML(word, child, rowSpanMap));
                        break;
                    case 'w:tblGrid':
                        table.tblGrid = parseTblGrid(child);
                        break;
                    default:
                        console.warn('Table.fromXML unknown tag', tagName, child);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return table;
    };
    return Table;
}());

export { Table };
