import { __values } from '../node_modules/tslib/tslib.es6.js';

/**
 * 解析字体
 * http://webapp.docx4java.org/OnlineDemo/ecma376/WordML/rFonts.html
 */
function themeFont(font) {
    return "var(--docx-theme-font-".concat(font, ")");
}
function parseFont(word, element, style) {
    var e_1, _a;
    var fonts = [];
    var fontMapping = word.renderOptions.fontMapping;
    try {
        for (var _b = __values(element.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
            var attribute = _c.value;
            var name_1 = attribute.name;
            var value = attribute.value;
            switch (name_1) {
                case 'w:ascii':
                case 'w:cs':
                case 'w:eastAsia':
                    if (fontMapping && value in fontMapping) {
                        value = fontMapping[value];
                    }
                    if (value.indexOf(' ') === -1) {
                        fonts.push(value);
                    }
                    else {
                        fonts.push('"' + value + '"');
                    }
                    break;
                case 'w:asciiTheme':
                case 'w:csTheme':
                case 'w:eastAsiaTheme':
                    fonts.push(themeFont(value));
                    break;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // hint 之类的不支持，因为也很难控制到这个粒度了
    if (fonts.length) {
        style['font-family'] = Array.from(new Set(fonts)).join(', ');
    }
}

export { parseFont };
