/**
 * amis-core v2.9.0
 * Copyright 2018-2023 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var get = require('lodash/get');
var endsWith = require('lodash/endsWith');
var isEmpty = require('lodash/isEmpty');
var isEqual = require('lodash/isEqual');
var startsWith = require('lodash/startsWith');
var resolveVariableAndFilterForAsync = require('./resolveVariableAndFilterForAsync.js');
var moment = require('moment');
var capitalize = require('lodash/capitalize');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var get__default = /*#__PURE__*/_interopDefaultLegacy(get);
var endsWith__default = /*#__PURE__*/_interopDefaultLegacy(endsWith);
var isEmpty__default = /*#__PURE__*/_interopDefaultLegacy(isEmpty);
var isEqual__default = /*#__PURE__*/_interopDefaultLegacy(isEqual);
var startsWith__default = /*#__PURE__*/_interopDefaultLegacy(startsWith);
var moment__default = /*#__PURE__*/_interopDefaultLegacy(moment);
var capitalize__default = /*#__PURE__*/_interopDefaultLegacy(capitalize);

var conditionResolverMap = {};
var DEFAULT_RESULT = true;
function resolveCondition(conditions, data, defaultResult) {
    if (defaultResult === void 0) { defaultResult = true; }
    return tslib.__awaiter(this, void 0, void 0, function () {
        return tslib.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!conditions ||
                        !conditions.conjunction ||
                        !Array.isArray(conditions.children) ||
                        !conditions.children.length) {
                        return [2 /*return*/, defaultResult];
                    }
                    return [4 /*yield*/, computeConditions(conditions.children, conditions.conjunction, data)];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
function computeConditions(conditions, conjunction, data) {
    if (conjunction === void 0) { conjunction = 'and'; }
    return tslib.__awaiter(this, void 0, void 0, function () {
        var computeResult, index, len, item, result, _a;
        return tslib.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    computeResult = true;
                    index = 0, len = conditions.length;
                    _b.label = 1;
                case 1:
                    if (!(index < len)) return [3 /*break*/, 7];
                    item = conditions[index];
                    if (!(item.conjunction && Array.isArray(item.children) && item.children.length)) return [3 /*break*/, 3];
                    return [4 /*yield*/, computeConditions(item.children, item.conjunction, data)];
                case 2:
                    _a = _b.sent();
                    return [3 /*break*/, 5];
                case 3: return [4 /*yield*/, computeCondition(item, index, data)];
                case 4:
                    _a = _b.sent();
                    _b.label = 5;
                case 5:
                    result = _a;
                    computeResult = !!result;
                    if ((result && conjunction === 'or') ||
                        (!result && conjunction === 'and')) {
                        return [3 /*break*/, 7];
                    }
                    _b.label = 6;
                case 6:
                    index++;
                    return [3 /*break*/, 1];
                case 7: return [2 /*return*/, computeResult];
            }
        });
    });
}
function computeCondition(rule, index, data) {
    var _a;
    return tslib.__awaiter(this, void 0, void 0, function () {
        var leftValue, rightValue, func;
        return tslib.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    leftValue = get__default["default"](data, rule.left.field);
                    return [4 /*yield*/, resolveVariableAndFilterForAsync.resolveVariableAndFilterForAsync(rule.right, data)];
                case 1:
                    rightValue = _b.sent();
                    func = (_a = conditionResolverMap["".concat(rule.op, "For").concat(capitalize__default["default"](rule.left.type))]) !== null && _a !== void 0 ? _a : conditionResolverMap[rule.op];
                    return [2 /*return*/, func ? func(leftValue, rightValue, rule.left.type) : DEFAULT_RESULT];
            }
        });
    });
}
function startsWithFunc(left, right) {
    if (left === undefined || right === undefined) {
        return DEFAULT_RESULT;
    }
    return startsWith__default["default"](left, right);
}
function endsWithFunc(left, right) {
    if (left === undefined || right === undefined) {
        return DEFAULT_RESULT;
    }
    return endsWith__default["default"](left, right);
}
function equalFunc(left, right) {
    return isEqual__default["default"](left, right);
}
function notEqualFunc(left, right) {
    return !isEqual__default["default"](left, right);
}
function isEmptyFunc(left) {
    if (typeof left === 'string') {
        return !left;
    }
    else if (typeof left === 'number') {
        return left === undefined;
    }
    else if (Array.isArray(left)) {
        return !left.length;
    }
    else if (typeof left === 'object') {
        return isEmpty__default["default"](left);
    }
    return DEFAULT_RESULT;
}
function isNotEmptyFunc(left) {
    if (typeof left === 'string') {
        return !left;
    }
    else if (typeof left === 'number') {
        return left !== undefined;
    }
    else if (Array.isArray(left)) {
        return !!left.length;
    }
    else if (typeof left === 'object') {
        return !isEmpty__default["default"](left);
    }
    return DEFAULT_RESULT;
}
function greaterFunc(left, right) {
    if (left === undefined || right === undefined) {
        return DEFAULT_RESULT;
    }
    return parseFloat(left) > parseFloat(right);
}
function normalizeDate(raw) {
    if (typeof raw === 'string' || typeof raw === 'number') {
        var formats = ['', 'YYYY-MM-DD HH:mm:ss', 'X'];
        if (/^\d{10}((\.\d+)*)$/.test(raw.toString())) {
            formats = ['X', 'x', 'YYYY-MM-DD HH:mm:ss', ''];
        }
        else if (/^\d{13}((\.\d+)*)$/.test(raw.toString())) {
            formats = ['x', 'X', 'YYYY-MM-DD HH:mm:ss', ''];
        }
        while (formats.length) {
            var format = formats.shift();
            var date = moment__default["default"](raw, format);
            if (date.isValid()) {
                return date.toDate();
            }
        }
    }
    return raw;
}
function normalizeDateRange(raw) {
    return (Array.isArray(raw) ? raw : raw.split(',')).map(function (item) {
        return normalizeDate(String(item).trim());
    });
}
function greaterForDateFunc(left, right) {
    left = normalizeDate(left);
    right = normalizeDate(right);
    return moment__default["default"](left).isAfter(moment__default["default"](right), 's');
}
function greaterOrEqualForDateFunc(left, right) {
    left = normalizeDate(left);
    right = normalizeDate(right);
    return moment__default["default"](left).isSameOrAfter(moment__default["default"](right), 's');
}
function greaterOrEqualFunc(left, right) {
    if (left === undefined || right === undefined) {
        return DEFAULT_RESULT;
    }
    return parseFloat(left) >= parseFloat(right);
}
function lessFunc(left, right) {
    if (left === undefined || right === undefined) {
        return DEFAULT_RESULT;
    }
    return parseFloat(left) < parseFloat(right);
}
function lessForDateFunc(left, right) {
    left = normalizeDate(left);
    right = normalizeDate(right);
    return moment__default["default"](left).isBefore(moment__default["default"](right), 's');
}
function lessOrEqualForDateFunc(left, right) {
    left = normalizeDate(left);
    right = normalizeDate(right);
    return moment__default["default"](left).isSameOrBefore(moment__default["default"](right), 's');
}
function lessOrEqualFunc(left, right) {
    if (left === undefined || right === undefined) {
        return DEFAULT_RESULT;
    }
    return parseFloat(left) <= parseFloat(right);
}
function likeFunc(left, right) {
    if (left === undefined || right === undefined) {
        return DEFAULT_RESULT;
    }
    return !!~left.indexOf(right);
}
function notLikeFunc(left, right) {
    if (left === undefined || right === undefined) {
        return DEFAULT_RESULT;
    }
    return !~left.indexOf(right);
}
function betweenFunc(left, right) {
    if (typeof left === 'number' && right !== undefined) {
        var _a = tslib.__read(right.sort(), 2), min = _a[0], max = _a[1];
        return left >= parseFloat(min) && left <= parseFloat(max);
    }
    return DEFAULT_RESULT;
}
function betweenForDateFunc(left, right) {
    if (right !== undefined) {
        var _a = tslib.__read(normalizeDateRange(right), 2), min = _a[0], max = _a[1];
        return moment__default["default"](normalizeDate(left)).isBetween(min, max, 's', '[]');
    }
    return DEFAULT_RESULT;
}
function notBetweenFunc(left, right) {
    if (typeof left === 'number' && right !== undefined) {
        var _a = tslib.__read(right.sort(), 2), min = _a[0], max = _a[1];
        return left < parseFloat(min) && left > parseFloat(max);
    }
    return DEFAULT_RESULT;
}
function notBetweenForDateFunc(left, right) {
    if (right !== undefined) {
        var _a = tslib.__read(normalizeDateRange(right), 2), min = _a[0], max = _a[1];
        return !moment__default["default"](normalizeDate(left)).isBetween(min, max, 's', '[]');
    }
    return DEFAULT_RESULT;
}
function selectAnyInFunc(left, right) {
    if (!Array.isArray(right)) {
        return DEFAULT_RESULT;
    }
    if (Array.isArray(left)) {
        return right.every(function (item) { return left.includes(item); });
    }
    return right.includes(left);
}
function selectNotAnyInFunc(left, right) {
    if (!Array.isArray(right)) {
        return DEFAULT_RESULT;
    }
    if (Array.isArray(left)) {
        return !right.every(function (item) { return left.includes(item); });
    }
    return !right.includes(left);
}
function registerConditionComputer(op, func, fieldType) {
    conditionResolverMap["".concat(op).concat(fieldType ? 'For' + capitalize__default["default"](fieldType) : '')] = func;
}
function getConditionComputers() {
    return conditionResolverMap;
}
registerConditionComputer('greater', greaterFunc);
registerConditionComputer('greater', greaterForDateFunc, 'date');
registerConditionComputer('greater', greaterForDateFunc, 'time');
registerConditionComputer('greater', greaterForDateFunc, 'datetime');
registerConditionComputer('greater_or_equal', greaterOrEqualFunc);
registerConditionComputer('greater_or_equal', greaterOrEqualForDateFunc, 'date');
registerConditionComputer('greater_or_equal', greaterOrEqualForDateFunc, 'time');
registerConditionComputer('greater_or_equal', greaterOrEqualForDateFunc, 'datetime');
registerConditionComputer('less', lessFunc);
registerConditionComputer('less', lessForDateFunc, 'date');
registerConditionComputer('less', lessForDateFunc, 'time');
registerConditionComputer('less', lessForDateFunc, 'datetime');
registerConditionComputer('less_or_equal', lessOrEqualFunc);
registerConditionComputer('less_or_equal', lessOrEqualForDateFunc, 'date');
registerConditionComputer('less_or_equal', lessOrEqualForDateFunc, 'time');
registerConditionComputer('less_or_equal', lessOrEqualForDateFunc, 'datetime');
registerConditionComputer('is_empty', isEmptyFunc);
registerConditionComputer('is_not_empty', isNotEmptyFunc);
registerConditionComputer('between', betweenFunc);
registerConditionComputer('between', betweenForDateFunc, 'date');
registerConditionComputer('between', betweenForDateFunc, 'time');
registerConditionComputer('between', betweenForDateFunc, 'datetime');
registerConditionComputer('not_between', notBetweenFunc);
registerConditionComputer('not_between', notBetweenForDateFunc, 'date');
registerConditionComputer('not_between', notBetweenForDateFunc, 'time');
registerConditionComputer('not_between', notBetweenForDateFunc, 'datetime');
registerConditionComputer('equal', equalFunc);
registerConditionComputer('not_equal', notEqualFunc);
registerConditionComputer('like', likeFunc);
registerConditionComputer('not_like', notLikeFunc);
registerConditionComputer('select_any_in', selectAnyInFunc);
registerConditionComputer('select_not_any_in', selectNotAnyInFunc);
registerConditionComputer('starts_with', startsWithFunc);
registerConditionComputer('ends_with', endsWithFunc);

exports.getConditionComputers = getConditionComputers;
exports.registerConditionComputer = registerConditionComputer;
exports.resolveCondition = resolveCondition;
