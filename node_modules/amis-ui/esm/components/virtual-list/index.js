/**
 * amis-ui v2.9.0
 * Copyright 2018-2023 fex
 */

import { __assign, __extends, __rest } from 'tslib';
import * as React from 'react';
import * as PropTypes from 'prop-types';
import SizeAndPositionManager from './SizeAndPositionManager.js';
import { SCROLL_CHANGE_REASON, DIRECTION, scrollProp, sizeProp, marginProp, oppositeMarginProp, positionProp, ALIGNMENT } from './constants.js';
export { DIRECTION as ScrollDirection } from './constants.js';
export { default as AutoSizer } from './AutoSizer.js';

/**
 * 基于 https://github.com/clauderic/react-tiny-virtual-list 改造，主要是加了宽度自适应
 */
var STYLE_WRAPPER = {
    overflow: 'auto',
    willChange: 'transform',
    WebkitOverflowScrolling: 'touch'
};
var STYLE_INNER = {
    position: 'relative',
    width: 'auto',
    whiteSpace: 'nowrap',
    minHeight: '100%'
};
var STYLE_ITEM = {
    position: 'absolute',
    top: 0,
    left: 0,
    width: 'auto'
};
var STYLE_STICKY_ITEM = __assign(__assign({}, STYLE_ITEM), { position: 'sticky' });
var VirtualList = /** @class */ (function (_super) {
    __extends(VirtualList, _super);
    function VirtualList() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.itemSizeGetter = function (itemSize) {
            return function (index) { return _this.getSize(index, itemSize); };
        };
        _this.sizeAndPositionManager = new SizeAndPositionManager({
            itemCount: _this.props.itemCount,
            itemSizeGetter: _this.itemSizeGetter(_this.props.itemSize),
            estimatedItemSize: _this.getEstimatedItemSize()
        });
        _this.state = {
            offset: _this.props.scrollOffset ||
                (_this.props.scrollToIndex != null &&
                    _this.getOffsetForIndex(_this.props.scrollToIndex)) ||
                0,
            scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED
        };
        _this.styleCache = {};
        _this.getRef = function (node) {
            node && (_this.rootNode = node);
        };
        _this.handleScroll = function (event) {
            var onScroll = _this.props.onScroll;
            var offset = _this.getNodeOffset();
            if (offset < 0 ||
                _this.state.offset === offset ||
                event.target !== _this.rootNode) {
                return;
            }
            _this.setState({
                offset: offset,
                scrollChangeReason: SCROLL_CHANGE_REASON.OBSERVED
            });
            if (typeof onScroll === 'function') {
                onScroll(offset, event);
            }
        };
        return _this;
    }
    VirtualList.prototype.componentDidMount = function () {
        var _a = this.props, scrollOffset = _a.scrollOffset, scrollToIndex = _a.scrollToIndex;
        this.rootNode.addEventListener('scroll', this.handleScroll, {
            passive: true
        });
        this.updateRootWidth();
        if (scrollOffset != null) {
            this.scrollTo(scrollOffset);
        }
        else if (scrollToIndex != null) {
            this.scrollTo(this.getOffsetForIndex(scrollToIndex));
        }
    };
    // 自适应宽度
    VirtualList.prototype.updateRootWidth = function () {
        var itemsDom = this.rootNode.children[0].children;
        var scrollbarWidth = window.innerWidth - document.documentElement.clientWidth || 15;
        var containerWidth = this.rootNode.parentElement.getBoundingClientRect().width;
        var maxItemWidth = 0;
        for (var i = 0; i < itemsDom.length; i++) {
            var itemWidth = itemsDom[i].getBoundingClientRect().width;
            if (itemWidth > maxItemWidth) {
                maxItemWidth = itemWidth;
            }
        }
        if (maxItemWidth > containerWidth) {
            this.rootNode.style.width = maxItemWidth + scrollbarWidth + 'px';
        }
    };
    VirtualList.prototype.componentDidUpdate = function (prevProps, prevState) {
        var props = this.props;
        var estimatedItemSize = prevProps.estimatedItemSize, itemCount = prevProps.itemCount, itemSize = prevProps.itemSize, scrollOffset = prevProps.scrollOffset, scrollToAlignment = prevProps.scrollToAlignment, scrollToIndex = prevProps.scrollToIndex;
        var scrollPropsHaveChanged = props.scrollToIndex !== scrollToIndex ||
            props.scrollToAlignment !== scrollToAlignment;
        var itemPropsHaveChanged = props.itemCount !== itemCount ||
            props.itemSize !== itemSize ||
            props.estimatedItemSize !== estimatedItemSize;
        if (props.itemSize !== itemSize) {
            this.sizeAndPositionManager.updateConfig({
                itemSizeGetter: this.itemSizeGetter(props.itemSize)
            });
        }
        if (props.itemCount !== itemCount ||
            props.estimatedItemSize !== estimatedItemSize) {
            this.sizeAndPositionManager.updateConfig({
                itemCount: props.itemCount,
                estimatedItemSize: this.getEstimatedItemSize(props)
            });
        }
        if (itemPropsHaveChanged) {
            this.recomputeSizes();
        }
        if (props.scrollOffset !== scrollOffset) {
            this.setState({
                offset: props.scrollOffset || 0,
                scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED
            });
        }
        else if (typeof props.scrollToIndex === 'number' &&
            (scrollPropsHaveChanged || itemPropsHaveChanged)) {
            this.setState({
                offset: this.getOffsetForIndex(props.scrollToIndex, props.scrollToAlignment, props.itemCount),
                scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED
            });
        }
        var _a = this.state, offset = _a.offset, scrollChangeReason = _a.scrollChangeReason;
        if (prevState.offset !== offset &&
            scrollChangeReason === SCROLL_CHANGE_REASON.REQUESTED) {
            this.scrollTo(offset);
        }
        if (props.itemCount !== itemCount) {
            // 长度发生变化时重新渲染
            this.forceUpdate();
        }
    };
    VirtualList.prototype.componentWillUnmount = function () {
        this.rootNode.removeEventListener('scroll', this.handleScroll);
    };
    VirtualList.prototype.scrollTo = function (value) {
        var _a = this.props.scrollDirection, scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;
        this.rootNode[scrollProp[scrollDirection]] = value;
    };
    VirtualList.prototype.getOffsetForIndex = function (index, scrollToAlignment, itemCount) {
        if (scrollToAlignment === void 0) { scrollToAlignment = this.props.scrollToAlignment; }
        if (itemCount === void 0) { itemCount = this.props.itemCount; }
        var _a = this.props.scrollDirection, scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;
        if (index < 0 || index >= itemCount) {
            index = 0;
        }
        return this.sizeAndPositionManager.getUpdatedOffsetForIndex({
            align: scrollToAlignment,
            containerSize: this.props[sizeProp[scrollDirection]],
            currentOffset: (this.state && this.state.offset) || 0,
            targetIndex: index
        });
    };
    VirtualList.prototype.recomputeSizes = function (startIndex) {
        if (startIndex === void 0) { startIndex = 0; }
        this.styleCache = {};
        this.sizeAndPositionManager.resetItem(startIndex);
    };
    VirtualList.prototype.render = function () {
        var _a;
        var _this = this;
        var _b = this.props; _b.estimatedItemSize; var height = _b.height, _c = _b.overscanCount, overscanCount = _c === void 0 ? 3 : _c, renderItem = _b.renderItem; _b.itemCount; _b.itemSize; var onItemsRendered = _b.onItemsRendered; _b.onScroll; var _d = _b.scrollDirection, scrollDirection = _d === void 0 ? DIRECTION.VERTICAL : _d; _b.scrollOffset; _b.scrollToIndex; _b.scrollToAlignment; var stickyIndices = _b.stickyIndices, style = _b.style, width = _b.width, WrapperComponent = _b.WrapperComponent, InnerComponent = _b.InnerComponent, prefix = _b.prefix, innerStyleFilter = _b.innerStyleFilter, props = __rest(_b, ["estimatedItemSize", "height", "overscanCount", "renderItem", "itemCount", "itemSize", "onItemsRendered", "onScroll", "scrollDirection", "scrollOffset", "scrollToIndex", "scrollToAlignment", "stickyIndices", "style", "width", "WrapperComponent", "InnerComponent", "prefix", "innerStyleFilter"]);
        var offset = this.state.offset;
        var _e = this.sizeAndPositionManager.getVisibleRange({
            containerSize: this.props[sizeProp[scrollDirection]] || 0,
            offset: offset,
            overscanCount: overscanCount
        }), start = _e.start, stop = _e.stop;
        var items = [];
        var wrapperStyle = __assign(__assign(__assign({}, STYLE_WRAPPER), style), { height: height, width: width });
        var innerStyle = __assign(__assign({}, STYLE_INNER), (_a = {}, _a[sizeProp[scrollDirection]] = this.sizeAndPositionManager.getTotalSize(), _a));
        if (stickyIndices != null && stickyIndices.length !== 0) {
            stickyIndices.forEach(function (index) {
                return items.push(renderItem({
                    index: index,
                    style: _this.getStyle(index, true)
                }));
            });
            if (scrollDirection === DIRECTION.HORIZONTAL) {
                innerStyle.display = 'flex';
            }
        }
        if (typeof start !== 'undefined' && typeof stop !== 'undefined') {
            for (var index = start; index <= stop; index++) {
                if (stickyIndices != null && ~stickyIndices.indexOf(index)) {
                    continue;
                }
                items.push(renderItem({
                    index: index,
                    style: this.getStyle(index, false)
                }));
            }
            if (typeof onItemsRendered === 'function') {
                onItemsRendered({
                    startIndex: start,
                    stopIndex: stop
                });
            }
        }
        var WrapperCmpt = WrapperComponent || 'div';
        var InnerCmpt = InnerComponent || 'div';
        return (React.createElement(WrapperCmpt, __assign({ ref: this.getRef }, props, { style: wrapperStyle }), prefix !== null && prefix !== void 0 ? prefix : null,
            React.createElement(InnerCmpt, { style: innerStyleFilter ? innerStyleFilter(innerStyle) : innerStyle }, items)));
    };
    VirtualList.prototype.getNodeOffset = function () {
        var _a = this.props.scrollDirection, scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;
        return this.rootNode[scrollProp[scrollDirection]];
    };
    VirtualList.prototype.getEstimatedItemSize = function (props) {
        if (props === void 0) { props = this.props; }
        return (props.estimatedItemSize ||
            (typeof props.itemSize === 'number' && props.itemSize) ||
            50);
    };
    VirtualList.prototype.getSize = function (index, itemSize) {
        if (typeof itemSize === 'function') {
            return itemSize(index);
        }
        return Array.isArray(itemSize) ? itemSize[index] : itemSize;
    };
    VirtualList.prototype.getStyle = function (index, sticky) {
        var _a, _b;
        var style = this.styleCache[index];
        if (style) {
            return style;
        }
        var _c = this.props.scrollDirection, scrollDirection = _c === void 0 ? DIRECTION.VERTICAL : _c;
        var _d = this.sizeAndPositionManager.getSizeAndPositionForIndex(index), size = _d.size, offset = _d.offset;
        return (this.styleCache[index] = sticky
            ? __assign(__assign({}, STYLE_STICKY_ITEM), (_a = {}, _a[sizeProp[scrollDirection]] = size, _a[marginProp[scrollDirection]] = offset, _a[oppositeMarginProp[scrollDirection]] = -(offset + size), _a.zIndex = 1, _a)) : __assign(__assign({}, STYLE_ITEM), (_b = {}, _b[sizeProp[scrollDirection]] = size, _b[positionProp[scrollDirection]] = offset, _b)));
    };
    VirtualList.defaultProps = {
        overscanCount: 3,
        scrollDirection: DIRECTION.VERTICAL,
        width: '100%'
    };
    VirtualList.propTypes = {
        estimatedItemSize: PropTypes.number,
        height: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
            .isRequired,
        itemCount: PropTypes.number.isRequired,
        itemSize: PropTypes.oneOfType([
            PropTypes.number,
            PropTypes.array,
            PropTypes.func
        ]).isRequired,
        onScroll: PropTypes.func,
        onItemsRendered: PropTypes.func,
        overscanCount: PropTypes.number,
        renderItem: PropTypes.func.isRequired,
        scrollOffset: PropTypes.number,
        scrollToIndex: PropTypes.number,
        scrollToAlignment: PropTypes.oneOf([
            ALIGNMENT.AUTO,
            ALIGNMENT.START,
            ALIGNMENT.CENTER,
            ALIGNMENT.END
        ]),
        scrollDirection: PropTypes.oneOf([
            DIRECTION.HORIZONTAL,
            DIRECTION.VERTICAL
        ]),
        stickyIndices: PropTypes.arrayOf(PropTypes.number),
        style: PropTypes.object,
        width: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
    };
    return VirtualList;
}(React.PureComponent));

export { VirtualList as default };
