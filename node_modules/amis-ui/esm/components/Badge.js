/**
 * amis-ui v2.9.0
 * Copyright 2018-2023 fex
 */

import { __extends, __assign } from 'tslib';
import React__default from 'react';
import hoistNonReactStatic from 'hoist-non-react-statics';
import { buildStyle, resolveVariableAndFilter, evalExpression } from 'amis-core';

/**
 * @file 角标组件
 */
var Badge = /** @class */ (function (_super) {
    __extends(Badge, _super);
    function Badge(props) {
        return _super.call(this, props) || this;
    }
    Badge.prototype.renderBadge = function (text, size, position, offsetStyle, sizeStyle, animationElement) {
        var _a = this.props, cx = _a.classnames, badge = _a.badge, data = _a.data;
        var _b = badge, _c = _b.mode, mode = _c === void 0 ? 'dot' : _c, _d = _b.level, level = _d === void 0 ? 'danger' : _d, style = _b.style;
        var customStyle = buildStyle(style, data);
        if (typeof level === 'string' && level[0] === '$') {
            level = resolveVariableAndFilter(level, data);
        }
        switch (mode) {
            case 'dot':
                return (React__default.createElement("span", { className: cx('Badge-dot', "Badge--".concat(position), "Badge--".concat(level)), style: __assign(__assign(__assign({}, offsetStyle), sizeStyle), customStyle) }, animationElement));
            case 'text':
                return (React__default.createElement("span", { className: cx('Badge-text', "Badge--".concat(position), "Badge--".concat(level)), style: __assign(__assign(__assign({}, offsetStyle), sizeStyle), customStyle) },
                    text,
                    animationElement));
            case 'ribbon':
                var outSize = size * Math.sqrt(2) + 5;
                return (React__default.createElement("div", { className: cx('Badge-ribbon-out', "Badge-ribbon-out--".concat(position)), style: { width: outSize, height: outSize } },
                    React__default.createElement("span", { className: cx('Badge-ribbon', "Badge-ribbon--".concat(position), "Badge--".concat(level)), style: __assign(__assign({}, sizeStyle), customStyle) },
                        text,
                        animationElement)));
            default:
                return null;
        }
    };
    Badge.prototype.render = function () {
        var badge = this.props.badge;
        if (!badge) {
            return this.props.children;
        }
        var _a = this.props, children = _a.children, cx = _a.classnames, data = _a.data;
        var isDisplay = true;
        if (typeof badge === 'string') {
            isDisplay = evalExpression(badge, data) === true;
        }
        var _b = badge.mode, mode = _b === void 0 ? 'dot' : _b, text = badge.text; badge.level; var size = badge.size, style = badge.style, offset = badge.offset, _c = badge.position, position = _c === void 0 ? 'top-right' : _c, _d = badge.overflowCount, overflowCount = _d === void 0 ? 99 : _d, visibleOn = badge.visibleOn, className = badge.className, animation = badge.animation;
        if (visibleOn) {
            isDisplay = evalExpression(visibleOn, data) === true;
        }
        if (typeof text === 'string' && text[0] === '$') {
            text = resolveVariableAndFilter(text, data);
        }
        // 设置默认值
        if (typeof size === 'undefined') {
            if (mode === 'dot') {
                size = 6;
            }
            else if (mode === 'ribbon') {
                size = 12;
            }
            else {
                size = 16;
            }
        }
        var sizeStyle = {};
        if (mode === 'text') {
            sizeStyle = {
                borderRadius: size / 2,
                height: size + 2,
                lineHeight: size + 'px'
            };
            // 当text、overflowCount都为number类型时，进行封顶值处理
            // 当text从模版字符串解析（text: "${badge}"）数字就会变为字符串
            // 因此当设置了overflowCount属性时 如果text可以强制转换成数字 那么也进行封顶处理
            if (typeof overflowCount === 'number' &&
                (typeof text === 'number' || (text && !isNaN(Number(text))))) {
                text = (text > overflowCount
                    ? "".concat(overflowCount, "+")
                    : text);
            }
            if (!text) {
                isDisplay = false;
            }
        }
        if (mode === 'dot') {
            sizeStyle = { width: size, height: size };
        }
        if (mode === 'ribbon') {
            sizeStyle = {
                height: size,
                lineHeight: size + 'px',
                fontSize: size
            };
        }
        var offsetStyle = {};
        if (offset && offset.length) {
            var left = "calc(50% + ".concat(parseInt(offset[0], 10), "px)");
            var right = "calc(-50% + ".concat(parseInt(offset[1], 10), "px)");
            offsetStyle = {
                transform: "translate(".concat(left, ", ").concat(right, ")")
            };
        }
        var animationBackground = 'var(--danger)';
        if (style && style.background) {
            animationBackground = style.background;
        }
        var animationElement = animation ? (React__default.createElement("div", { style: {
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: '100%',
                border: "1px solid ".concat(animationBackground),
                borderRadius: '50%',
                animation: 'badgeDotAnimation 1.2s infinite ease-in-out'
            } })) : null;
        return (React__default.createElement("div", { className: cx('Badge', className) },
            children,
            isDisplay
                ? this.renderBadge(text, size, position, offsetStyle, sizeStyle, animationElement)
                : null));
    };
    Badge.propsList = ['body', 'className', 'children'];
    return Badge;
}(React__default.Component));
function withBadge(Component) {
    var _a;
    return hoistNonReactStatic((_a = /** @class */ (function (_super) {
            __extends(WithBadge, _super);
            function WithBadge() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            WithBadge.prototype.render = function () {
                var badge = this.props.badge;
                if (!badge) {
                    return React__default.createElement(Component, __assign({}, this.props));
                }
                return (React__default.createElement(Badge, __assign({}, this.props),
                    React__default.createElement(Component, __assign({}, this.props))));
            };
            return WithBadge;
        }(React__default.Component)),
        _a.displayName = "WithBadge(".concat(Component.displayName || Component.name, ")"),
        _a), Component);
}

export { Badge, withBadge };
